/*
  Given a pair of read_ids, and a list of directories with their seeds (with window info,
  generated by genSubseqSeeds2Window), output to stdout the highest colinear chaining score 
  among the seed matches.

  The chaining score is defined following minimap2:
  A seed match is a pair (x, y), indicating window [x, x+n-1] on read1 and [y, y+n-1] on
  read2 have a matching seed (if the match is from opposite strands, y'=-y-n is used, i.e.,
  index of y+n-1 from the reverse direction, instead of y).
  
  Given a list of matches (xi, yi), let f(i) be the maximal chaining score up to the ith
  seed match, then
  f(i) = max( max_{i>j}( f(j)+a(j,i)-b(j,i) ), n )
  where a(j,i) = min( min( yi-yj, xi-xj ), n );
  b(j, i)=c( (yi-yj)-(xi-xj) ); c(l)=0.01n|l| + 0.5log_2|l| if l=/=0, or 0 if l=0

  **b(j, i) is set to infinity (i.e., do not chain j and i) if 
  1. yj>yi, or
  2. max(yi-yj, xi-xj)>max_gap (i.e., distance between two matches is too large), or
  3. |(yi-yj)-(xi-xj)|>band_width (i.e., gap on one read is significantly larger than on another read)

  By: Ke@PSU
  Last edited: 10/02/2023
*/

#include "../util.h"
#include <sys/stat.h>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <cmath>

struct SeedInfo{
    int read_id;
    int st, ed;
    int window_st;
    int strand;
    SeedInfo(int id, int s, int t, int w, int p):
	read_id(id), st(s), ed(t), window_st(w), strand(p){}
};

int loadWindowSeedsWithInfo(const char* filename, const int read_id,
			     std::unordered_map<kmer, std::vector<SeedInfo>, kmerHash>& all_seeds){
    FILE* fin = fopen(filename, "rb");
    size_t ret = 1;
    kmer s;
    int k;
    int strand = 0, pre_w = -1;
    int loc[3];//st, ed, windowst
    ret = fread(&k, sizeof(k), 1, fin);
    while(true){
	ret = fread(&s, sizeof(s), 1, fin);
	if(ret != 1) break;

	ret = fread(loc, sizeof(int), 3, fin);

	if(loc[2] < pre_w){//start reading seeds from the opposite strand
	    strand = 1;
	}
	pre_w = loc[2];
	
	auto result = all_seeds.emplace(s, std::vector<SeedInfo>());
	//result.first is either newly inserted or a previous existing entry
	result.first->second.emplace_back(read_id, loc[0], loc[1], loc[2], strand);
    }
    if(ferror(fin)){
	fprintf(stderr, "Error reading %s\n", filename);
	return -1;
    }
    fclose(fin);
    return k;
}


struct SeedMatch{
    int x, y;
    SeedMatch(int a, int b): x(a), y(b){}
    friend bool operator<(const SeedMatch& a, const SeedMatch& b){
	if(a.x == b.x) return a.y < b.y;
	else return a.x < b.x;
    }
    friend bool operator==(const SeedMatch& a, const SeedMatch& b){
	return a.x == b.x && a.y == b.y;
    }
};

int computeScore(const SeedMatch& mi, const SeedMatch& mj,
		 const int n, const int max_gap, const int band_width){
    int d1 = mi.x - mj.x;
    //if(d1 == 0 || d1 > max_gap) return INT32_MIN;
    if(d1 > max_gap) return INT32_MIN;
    int d2 = mi.y - mj.y;
    //if(d2 <= 0 || d2 > max_gap) return INT32_MIN;
    if(d2 > max_gap) return INT32_MIN;

    int ad2 = d2 < 0 ? -d2 : d2;
    //matches overlap more than half
    if(d1 < (n>>1) && ad2 < (n>>1)) return (d1<ad2? d1 : d2)+1;
    else if(d2 < 0) return INT32_MIN;

    int d_diff, d_min;
    if(d1 > d2){
	d_diff = d1-d2;
	d_min = d2;
    }else{
	d_diff = d2-d1;
	d_min = d1;
    }
    if(d_diff > band_width) return INT32_MIN;

    //if d_min is small and d_diff<4, this will produce a positive score to encourage 
    //including overlapping seed matches
    int score = d_min < 2? 2 : (d_min < n? d_min : n);

    double lin_pen = 0.01*n*d_diff;// + 0*n*d_min; //minimap2 by default has chn_pen_skip=0
    double log_pen = d_diff > 0? 0.5*std::log2(d_diff) : 0;
    
    return score - (int)(lin_pen + log_pen);
}

/*
 * m is assumed to be asc sorted, duplicates removed.
 * pos: 0,1 - begin and end positions of best chain on read1;
        2,3 - begin and end positions of best chain on read2.
*/
int doChaining(const std::vector<SeedMatch>& m, const int n,
	       const int max_gap, const int band_width,
	       size_t* num_nodes_on_chain, int pos[4]){
    if(m.empty()){
	*num_nodes_on_chain = 0;
	return 0;
    }

    size_t len = m.size();
    //int f[len];//f[i]: highest score among any chain end at match i
    //int64_t p[len];//p[i]: prev match to chain to, for backtracking
    //size_t ct[len];//ct[i]: num of matches in the chain achieves f[i]

    std::vector<int> f(len);
    std::vector<int64_t> p(len);
    std::vector<size_t> ct(len);

    for(size_t i=0; i<len; ++i){
	int64_t max_j = -1;
	int max_f = n;
	for(int64_t j=i-1; j>=0; --j){
	    int cur_f = computeScore(m[i], m[j], n, max_gap, band_width);
	    if(cur_f == INT32_MIN) continue;
	    cur_f += f[j];
	    if(cur_f > max_f){
		max_f = cur_f;
		max_j = j;
	    }
	}
	f[i] = max_f;
	p[i] = max_j;
	ct[i] = max_j>=0? ct[max_j]+1 : 1;
    }

    size_t max_i = 0;
    int max_f = f[max_i];
    for(size_t i=1; i<len; ++i){
	if(f[i] > max_f){
	    max_f = f[i];
	    max_i = i;
	}
    }
    *num_nodes_on_chain = ct[max_i];

    size_t st = max_i;
    while(p[st] > 0){
	st = p[st];
    }
    pos[0] = m[st].x;
    pos[2] = m[st].y>0? m[st].y : -m[st].y-n;
    pos[1] = m[max_i].x;
    pos[3] = m[max_i].y>0? m[max_i].y : -m[max_i].y-n;
    
    return max_f;
}

int main(int argc, const char * argv[])    
{   
    if(argc < 8){
	fprintf(stderr, "Usage: subseq2Chaining.out read_id1 read_id2 n max_gap band_width num_results dir_1 ... dir_n\n**WARNING**: output to stdout!\nread_id1\nread_id2\nbest_score\nnum_matches_on_chain\ntotal_num_unique_matches\nst_on_read1\ned_on_read1\nst_on_read2\ned_on_read2\n");
	return 1;
    }

    int x = atoi(argv[1]);
    int y = atoi(argv[2]);
    int n = atoi(argv[3]);
    int max_gap = atoi(argv[4]);
    int band_width = atoi(argv[5]);
    int num_results = atoi(argv[6]);
    
    if(argc != 7+num_results){
	fprintf(stderr, "Indicate %d sets of results, only provided %d directories\n", num_results, argc-7);
	return 1;
    }

    if(x>y){
	int tmp = x;
	x = y;
	y = tmp;
    }

    int i;
    char dirname[200];
    struct stat test_file;

    std::vector<SeedMatch> same;
    std::vector<SeedMatch> opposite;

    for(i=7; i<argc; ++i){
	int l = strlen(argv[i]);
	memcpy(dirname, argv[i], l);
	if(dirname[l-1] != '/'){
	    dirname[l] = '/';
	    ++l;
	}

	std::unordered_map<kmer, std::vector<SeedInfo>, kmerHash> seeds;
	
	sprintf(dirname+l, "%d.subseqseed2w", x);	
	if(stat(dirname, &test_file) != 0){
	    fprintf(stderr, "Stopped, cannot find file %s\n", dirname);
	    break;
	}
	loadWindowSeedsWithInfo(dirname, x, seeds);

	sprintf(dirname+l, "%d.subseqseed2w", y);
	if(stat(dirname, &test_file) != 0){
	    fprintf(stderr, "cannot find file %s\n", dirname);
	    break;
	}
	loadWindowSeedsWithInfo(dirname, y, seeds);

	for(const auto& z : seeds){
	    size_t l = z.second.size();
	    for(size_t a=0; a<l; ++a){
		const SeedInfo& c1 = z.second[a];
		for(size_t b=a+1; b<l; ++b){
		    const SeedInfo& c2 = z.second[b];
		    if(c1.read_id < c2.read_id){
			if(c1.strand == c2.strand)
			    same.emplace_back(c1.window_st, c2.window_st);
			else
			    opposite.emplace_back(c1.window_st, -n-c2.window_st);
		    }else if(c1.read_id > c2.read_id){
			if(c1.strand == c2.strand)
			    same.emplace_back(c2.window_st, c1.window_st);
			else
			    opposite.emplace_back(c2.window_st, -n-c1.window_st);
		    }
		}
	    }
	}
    }

    std::sort(same.begin(), same.end());
    same.erase(std::unique(same.begin(), same.end()), same.end());

    int same_pos[4];
    size_t same_nodes_on_chain;
    int same_sc = doChaining(same, n, max_gap, band_width,
			     &same_nodes_on_chain, same_pos);
    
    std::sort(opposite.begin(), opposite.end());
    opposite.erase(std::unique(opposite.begin(), opposite.end()), opposite.end());

    int opposite_pos[4];
    size_t opposite_nodes_on_chain;
    int opposite_sc = doChaining(opposite, n, max_gap, band_width,
				 &opposite_nodes_on_chain, opposite_pos);

    if(same_sc > opposite_sc){
	printf("%d %d %d %zu %zu %d %d %d %d\n", x, y,
		same_sc, same_nodes_on_chain,
	       same.size()+opposite.size(), same_pos[0], same_pos[1],
	       same_pos[2], same_pos[3]);
    }else{
	printf("%d %d %d %zu %zu %d %d %d %d\n", x, y,
		opposite_sc, opposite_nodes_on_chain,
	       same.size()+opposite.size(), opposite_pos[0], opposite_pos[1],
	       opposite_pos[2], opposite_pos[3]);
    }

    return 0;
}
