/*
  Given a pair of read_ids, and a list of directories with their seeds (with window info,
  generated by genSubseqSeeds2Window), output to stdout in a similar format as LASTZ:

  two columns, one for each read, separated by a tab;
  first row is the read_ids (table heads);
  followed by 3 rows per group: row 1 is the start positions of a seed match, row 2 is the end position, row 3 is "NA\tNA" as a separater;
  [optional] last two rows is the lengths of the two reads (so the dotplot covers the whole reads) and the separater "NA\tNA".
  
  
  By: Ke@PSU
  Last edited: 12/12/2023
*/

#include "../util.h"
#include <sys/stat.h>
#include <iostream>
#include <fstream>
#include <inttypes.h> //for PRIu64

struct SeedInfo{
    int read_id;
    uint64_t st, ed;
    int strand;
    SeedInfo(int id, int s, int t, int p):
	read_id(id), st(s), ed(t), strand(p){}
};

int loadWindowSeedsWithInfo(const char* filename, const int read_id,
			    const int strand, const uint64_t read_len, const int seed_len,
			    std::unordered_map<kmer, std::vector<SeedInfo>, kmerHash>& all_seeds){
    FILE* fin = fopen(filename, "rb");
    size_t ret = 1;
    kmer s;
    int k;
    uint64_t loc[2];//st, index
    ret = fread(&k, sizeof(k), 1, fin);
    while(true){
	ret = fread(&s, sizeof(s), 1, fin);
	if(ret != 1) break;
	//skip score and psi
	fseek(fin, sizeof(int64_t)+sizeof(short), SEEK_CUR);
	
	ret = fread(loc, sizeof(uint64_t), 2, fin);
	
	auto result = all_seeds.emplace(s, std::vector<SeedInfo>());
	//result.first is either newly inserted or a previous existing entry
	if(strand == 0){
	    result.first->second.emplace_back(read_id, loc[0], loc[0]+seed_len-1, strand);
	}else{
	    result.first->second.emplace_back(read_id, read_len-1-loc[0],
					      read_len-1-loc[0]-seed_len+1, strand);
	}
    }
    if(ferror(fin)){
	fprintf(stderr, "Error reading %s\n", filename);
	return -1;
    }
    fclose(fin);
    return k;
}

void printSeedMatch(const SeedInfo& a, const SeedInfo& b){    
    printf("%" PRIu64 "\t%" PRIu64 "\n%" PRIu64 "\t%" PRIu64 "\nNA\tNA\n",
	   a.st, b.st, a.ed, b.ed);
}


int main(int argc, const char * argv[])    
{   
    if(argc != 9){
	fprintf(stderr, "Usage: subseq2Dotplot.out read_id1 read_len1 read_id2 read_len2 n num_results dir file_ext\n**WARNING**: output to stdout!\n");
	return 1;
    }

    int x = atoi(argv[1]);
    int x_len = atoi(argv[2]);
    int y = atoi(argv[3]);
    int y_len = atoi(argv[4]);
    int n = atoi(argv[5]);
    int num_results = atoi(argv[6]);

    bool is_self = false;
    
    if(x==y){
	is_self = true;
    }else if(x>y){
	int tmp = x;
	x = y;
	y = tmp;
    }

    int i;
    char dirname[200];
    struct stat test_file;

    int l = strlen(argv[7]);
    memcpy(dirname, argv[7], l);
    if(dirname[l-1] != '/'){
	dirname[l] = '/';
	++l;
    }
    
    printf("%d\t%d\n", x, y);

    for(i=0; i<(num_results<<1); i+=2){
	std::unordered_map<kmer, std::vector<SeedInfo>, kmerHash> seeds;
	
	sprintf(dirname+l, "%d-%d.%s", i, x, argv[8]);	
	if(stat(dirname, &test_file) != 0){
	    fprintf(stderr, "Stopped, cannot find file %s\n", dirname);
	    break;
	}
	loadWindowSeedsWithInfo(dirname, x, 0, x_len, n, seeds);

	sprintf(dirname+l, "%d-%d.%s", i+1, x, argv[8]);	
	if(stat(dirname, &test_file) != 0){
	    fprintf(stderr, "Stopped, cannot find file %s\n", dirname);
	    break;
	}
	loadWindowSeedsWithInfo(dirname, x, 1, x_len, n, seeds);

	if(!is_self){
	    sprintf(dirname+l, "%d-%d.%s", i, y, argv[8]);
	    if(stat(dirname, &test_file) != 0){
		fprintf(stderr, "cannot find file %s\n", dirname);
		break;
	    }
	    loadWindowSeedsWithInfo(dirname, y, 0, y_len, n, seeds);

	    sprintf(dirname+l, "%d-%d.%s", i+1, y, argv[8]);
	    if(stat(dirname, &test_file) != 0){
		fprintf(stderr, "cannot find file %s\n", dirname);
		break;
	    }
	    loadWindowSeedsWithInfo(dirname, y, 1, y_len, n, seeds);
	}

	for(const auto& z : seeds){
	    size_t l = z.second.size();
	    for(size_t a=0; a<l; ++a){
		const SeedInfo& c1 = z.second[a];
		if(!is_self){
		    for(size_t b=a+1; b<l; ++b){
			const SeedInfo& c2 = z.second[b];
			if(c1.read_id < c2.read_id){
			    printSeedMatch(c1, c2);
			}else if(c1.read_id > c2.read_id){
			    printSeedMatch(c2, c1);
			}
		    }
		}else{
		    for(size_t b=a; b<l; ++b){
			const SeedInfo& c2 = z.second[b];
			printSeedMatch(c1, c2);
		    }
		}
	    }
	}
    }
    
    return 0;
}
